\documentclass[12pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsthm,amssymb}
\usepackage[none]{hyphenat}
\usepackage{mathtools}
\usepackage{verbatim}
\usepackage[ruled]{algorithm2e}
\setlength{\parindent}{0pt}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}

\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
  \newenvironment{lemma}[2][Lemma]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
  \newenvironment{exercise}[2][Exercise]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
  \newenvironment{problem}[2][Problem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
  \newenvironment{question}[2][Question]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
  \newenvironment{corollary}[2][Corollary]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\SetKwInput{KwInput}{Input}
\SetKwInput{KwOutput}{Output}
\SetKwInput{KwLet}{Let}

\begin{document}

\title{Assignment 2}%replace X with the appropriate number
\author{Quinn Perfetto, 104026025\\ %replace with your name
 60-454 Design and Analysis of Algorithms} %if necessary, replace with your course title

\maketitle

\begin{question}{1 (a)}
  \leavevmode \\ \\
  \begin{algorithm}[H]
    \KwInput{$L[lower..upper], lower \leq i \leq upper,\ L[i] \in \{0, 1\}$}
    \KwOutput{$L[lower..upper]$ sorted in ascending order}
    \caption{FlipSort(L, lower, upper)}
    \BlankLine

    \Begin{
      \If{upper - lower $>$ 1}{
        FlipSort(L, lower, $\floor{\frac{lower + upper}{2}}$)\;
        FlipSort(L, $\floor{\frac{lower + upper}{2}}$ + 1, upper)\;
        \KwRet{Merge($L\bigl[lower..\floor{\frac{lower + upper}{2}}\bigr]$,
        $L\bigl[\floor{\frac{lower + upper}{2}} + 1..upper\bigr]$)}
      }
    }
  \end{algorithm}

  \begin{algorithm}
    \caption{Merge(A, B)}
    \KwInput{Two sorted lists $A[1..n]$ and $B[1..m]$ over $\{0, 1\}$}
    \KwOutput{A sorted list $C[1..m+n]$ containing all elements of $A$ and $B$}
    \KwLet{$<>$ be the list concatenation operator}
    \BlankLine
    \Begin{
      $index_{A}$ := SequentialSearch(A, 1)\;
      $index_{B}$ := SequentialSearch(B, 1)\;
      \If{$index_{A} == 0$} {
        \KwRet{$A <> B$}
      }

      \If{$index_{B} == 0$} {
        \KwRet{$B <> A$}
      }

      \KwRet{$A[1..index_{A} - 1] <> flip(A[index_{A}..n] <> B[1..index_{B} - 1])
      <> B[index_{B}..m]$}
    }
  \end{algorithm}

  \begin{lemma}{1.1} Algorithm Merge correctly produces a sorted list
    \leavevmode \\ \\
    Note that SequentialSearch(L, x) refers to the algorithm defined in Chapter 0
    Page 10 of the CourseWare, and returns the index of the first occurrence
    of $x$ in $L$ if it exists, and $0$ otherwise. For the sake of brevity,
    we take $L[1..0]$ as $[]$ (the empty list). \\

    \textbf{Case 1:} $index_{A} == 0$\\
    $index_{A} == 0 \Rightarrow A$ contains no instance of 1, i.e.
    $ 1 \leq i \leq n,\ A[i] == 0$.  Since $0 \leq 0 \leq 1$ and $B$ is assumed
    to be a sorted list over $\{0, 1\}$, by the transitivity of $\leq$ $A <> B$
    must also be sorted. Thus the algorithm works correctly.\\

    \textbf{Case 2:} $index_{B} == 0$\\
    This case is similar to the above case, I thus omit the detail. \\

    \textbf{Case 3:} $index_{A} \geq 1 \land index_{B} \geq 1$\\
    Without loss of generality, let $A = 0^{x}1^{n-x}$ and
    $B = 0^{y}1^{m-y}$ such that $x, y \geq 0,\ x \leq n,\ y \leq m$.
    Since $index_{A}$ refers to the first occurrence of $1$ in $A$,
    $A[1..index_{A} - 1] = 0^{x}$ and $A[index_{A}..n] = 1^{n-x}$.  By a similar
    argument for $index_{B}$, $B[1..index_{B} - 1] = 0^{y}$ and $B[index_{B}..m] = 1^{m-y}$.
    Thus,
    \begin{align*}
      & A[1..index_{A} - 1] <> flip(A[index_{A}..n] <> B[1..index_{B} - 1]) <> B[index_{B}..m] &\\
      & = 0^{x} <> flip(1^{n-x}, 0^{y}) <> 1^{m-y} & \\
      & = 0^{x} <> (0^{y} <> 1^{n-x}) <> 1^{m-y} & \\
      & = 0^{x}0^{y}1^{n-x}1^{m-y} &
    \end{align*}
    Which is a sorted list of length $x + y + n - x + m - y = n + m$.
    Therefore the algorithm works correctly.
  \end{lemma}

  \begin{lemma}{1.2} Algorithm FlipSort correctly produces a sorted list.
    \leavevmode \\ \\
    Induction on the size of the input $n$.\\
    (Induction Basis) If $n=1$ FlipSort performs no operations and returns a
    single element list which is vacuously sorted.\\
    (Induction Hypothesis) Assume that FlipSort correctly sorts all lists of size $n \leq k,\ n > 1$. \\
    (Induction Step) Let $L'[lower..upper]$ be a list of length $k + 1$, i.e.
    $upper - lower = k + 1$.  The first recursive call produces a list of length,
    \begin{align*}
       & \floor{\frac{lower + upper}{2}} - lower &\\
       & \leq \frac{lower + upper}{2} - lower & \\
       & = \frac{upper-lower}{2} & \\
       & < upper - lower & (n > 1) & \\
       & = k + 1 & 
    \end{align*}
    Thus by the Inductive Assumption the first recursive call produces a correctly
    sorted list $L'[lower..\floor{\frac{lower + upper}{2}}]$ (I).\\
    Additionally the second recursive call produces a list of length,
    \begin{align*}
      & upper  - \floor{\frac{lower + upper}{2}} + 1 & \\
      & \leq upper - \frac{lower + upper}{2} + 1 & \\
      & = \frac{upper - lower}{2} + 1 &\\
      & = \frac{k + 1}{2} + 1 &\\
      & < k + 1 & (k + 1 > 2)
    \end{align*}
    Thus by the Inductive Assumption the second recursive call produces a correctly
    sorted list $L'[\floor{\frac{lower + upper}{2}}..upper]$ (II). \\ \\
    Finally by Lemma 1.1, (I) and (II) we know that the Merge Algorithm correctly
    merges the resulting lists into a sorted list $L'[lower..upper]$.\\
    Therefore Algorithm FlipSort works correctly.
  \end{lemma}

  \begin{lemma}{1.3} Algorithm Merge requires at most $2n + 2m$ operations \\ \\
    As proved in the CourseWare SequentialSearch search performs at most $n$
    comparisons for $index_{A}$ and at most $m$ comparisons for $index_{B}$.
    Further, since $Flip$ requires $O(j - i)$ time and $j - i \leq n + m$ we
    have at most $(n + m) + (n + m) = 2n + 2m$ operations.
  \end{lemma}

  \begin{lemma}{1.4} Algorithm FlipSort is $\theta(nlgn)$ \\ \\
    Let $T(n)$ be the time required to sort a list of $n$ elements with FlipSort.\\
    \[
      T(n) = \begin{cases}
                T(\floor{\frac{n}{2}}) + T(\ceil{\frac{n}{2}}) + 2n & n > 1 \\
                0                                    & otherwise \\
             \end{cases}
    \]

    Let $T_{\floor{}}(n) = 2T(\floor{\frac{n}{2}}) + 2n$ and $T_{\ceil{}}(n) = 2T(\ceil{\frac{n}{2}}) + 2n$. \\
    Using the general formula for solving recurrences, we have\\
    $f(n) = 2n = \theta(n) = \theta(n^{log_{2}2}) = \theta(n^{log_{b}a}lg^{0}n)$\\ \\
    Therefore $T_{\floor{}}(n) = T_{\ceil{}}(n) = \theta(nlgn)$.\\
    Then $T_{\floor{}}(n) \leq T(n) \leq T_{\ceil{}}(n) \Rightarrow T(n) = \theta(nlgn)$. \\ \\
    Therefore Algorithm FlipSort correctly sorts the input and runs in $\theta(nlgn)$ time. $\blacksquare$
  \end{lemma}
\end{question}

\begin{question}{1 (b)}
  \leavevmode \\
  \begin{algorithm}
    \caption{InsertFlipSort}
    \KwInput{An array of elements $A[1..n]$ drawn from a totally ordered set}
    \KwOutput{$A[1..n]$ sorted in ascending order}
    \BlankLine

    \Begin{
      \For{$i := 2$ \KwTo $n$} {
        j := i - 1\;
        \While{$A[j] \succ A[j + 1] \land j > 0$} {
          Flip($A$, j, j + 1)\;
          j := j - 1\;
        }
      }
    }
  \end{algorithm}
  \begin{lemma}{1.4} Algorithm InsertFlipSort correctly produces a sorted list \\ \\
    We shall prove by induction that just before the k$th$ iteration of the
    outer most for loop, $A[1..k]$ is sorted. \\
    (Induction Basis) For $k = 1$ we have $A[1..k] = A[1..1]$ which is a vacuously
    sorted single element list.\\
    (Induction Hypothesis) We assume just before the $k-1th$ iteration that
    $A[1..k - 1]$ is sorted.  We note that $i = k$. \\
    (Induction Step) In order to prove that this invariant holds after the $k-1th$
    iteration, we will apply induction on the number of iterations of the inner
    while loop to show that just before the m$th$ iteration of the loop,
    $A[k-m+1..k]$ is sorted. \\ \\
    (Induction Basis') When $m = 1$, $A[k-m+1..k] = A[k..k]$ which is a vacuously
    sorted single element list.\\
    (Induction Hypothesis') Suppose that just before the $m-1th$ iteration
    $A[k-(m-1)+1..k] = A[k-m+2..k]$ is sorted.  Note that $j = k - (m - 1) = k - m +1$.\\
    (Induction Step') Following the $m-1th$ iteration we have,
    \begin{align*}
      & A[j] \succ A[j + 1] \land j > 0 &\\
      & \Rightarrow A[k-m+1] \succ A[k-m+2] \land k-m+1 > 0 &
    \end{align*}
    Calling Flip(A, k - m +1, k - m +2) effectively swaps the two positions
    as they are adjacent in the array.  Following the call to Flip we have,
    \begin{align*}
      & A[k-m+1] \lesssim A[k-m+2] \land A[k-m+2..k] \text{ is sorted} & \\
      & \Rightarrow A[k-m+1..k] \text{ is sorted} &\\
    \end{align*}
    Therefore just before the start of the m$th$ iteration $A[k-m+1..k]$ is sorted,
    i.e. the proposed invariant holds for all iterations of the loop (I).\\ \\
    (Induction Step) Given (I), and substituting $j$ for $k-m$, upon terminaiton
    of the inner while loop we have,
    \begin{align*}
      & A[1..k-1] \text{ is sorted} \land A[j + 1..k] \text{ is sorted} \land (j = 0 \lor A[j] \lesssim A[j + 1]) & (j = k - m)
    \end{align*}

    \textbf{Case 1:} j = 0\\
    This means that the inner while loop iterated $k-1$ times, following the
    $k-1th$ iteration we have,
    \begin{align*}
      A[j + 1..k] \text{ is sorted} \land j = 0 \Rightarrow A[1..k] \text{ is sorted}
    \end{align*}
    Thus the invariant holds. \\

    \textbf{Case 2:} $A[j] \lesssim A[j + 1]$ \\
    We thus have,
    \begin{align*}
      & A[j] \lesssim A[j + 1] \land A[j + 1..k] \text{ is sorted} & \\
      & \Rightarrow A[j..k] \text{ is sorted} & \\
      & A[1..k-1] \text{ is sorted} \land A[j..k] \text{ is sorted} \Rightarrow A[1..k] \text{ is sorted}
    \end{align*}
    Thus the invariant holds.\\
    Therefore Following the n$th$ iteration we have $A[1..n]$ is sorted.\\
    Hence, the Algorithm works correctly.
  \end{lemma}

  \begin{lemma}{1.5} FlipSort runs in O($n^{2}lgn$) time \\ \\
    \textbf{Key Operations:} Comparison of integers, calls to Flip \\
    Given that the inner while loop will perform at most $i - 1$ comparisons,
    and make at most $i - 1$ calls to Flip, each of which run in O($j + 1 - j$) = O(1) time,
    we have,
    \begin{align*}
      & \sum_{i=2}^{n} 2(i-1) &\\
      & = 2\sum_{i=2}^{n}i-1 &\\
      & = 2(\sum_{i=2}^{n}i - \sum_{i=2}^{n}1) &\\
      & = 2(\frac{n(n + 1)}{2} + 1 - (n - 1))&\\
      & = 2(\frac{n^{2} + n}{2} + 1 - n  + 1)&\\
      & = n^{2} - n + 4 & \\
      & = O(n^{2}) & \\
      & = O(n^{2}lgn) &
    \end{align*}
  \end{lemma}
\end{question}

\begin{question}{3}
  \leavevmode \\
  \begin{algorithm}
    \caption{MaximumMinimumDistance}
    \KwInput{A set of points $P$ in the Euclidean plane}
    \KwOutput{$\{W, \overline{W}\}$ such that $dist\{W, \overline{W}\}$ is
    maximized over all partitions of $P$}
    \KwLet{a weighted undirected edge $E$ be defined by the 2-tuple $(\{u, v\}, w)$
    where $u$ and $v$ are the endpoints of $E$ and $w$ is the weight}
    \BlankLine
    PairwiseDistanceGraph := $\{(\{u, v\},\ d(u, v))\ |\ u,\ v \in P\}$\;
    MST := MinimumSpanningTree(PairwiseDistanceGraph)\;
    HeaviestEdge := max(MST by w)\;
    W, $\overline{W}$ := PairwiseDistanceGraph - \{HeaviestEdge\}\;
  \end{algorithm}

  \begin{lemma}{3.1} Algorithm MaximumMinimumDistance correctly produces
    $\{W, \overline{W}\}$ \\

    We shall first prove that $\{W, \overline{W}\}$ is a disjoint parition
    of $P$.
    \begin{proof}
      Note that $\forall p \in P$, p is a vertex of PairwiseDistanceGraph.
      Since MinimumSpanningTree is assumed to work correctly, it follows that
      $\forall p \in P$, p is a vertex of MST (I).  Since every edge in a tree is
      a cut edge, MST - \{HeaviestEdge\} must produce a disconnected graph
      containing two disjoint components, i.e. $W$ and $\overline{W}$.
      By (I) we thus have $W \cap \overline{W} = \emptyset$ and
      $W \cup \overline{W} = P$.  Thus $\{W, \overline{W}\}$ is a disjoint
      partition of P.
    \end{proof}

    It remains to show that $dist(W, \overline{W})$ is maximum over all other
    paritions of P.

    \begin{proof}
      Suppose there exists a disjoint partition $\{X, \overline{X}\}$ of $P$ such
      that,
      \begin{align*}
        dist(X, \overline{X}) > dist(W, \overline{W}),\ \{X, \overline{X}\} \neq \{W, \overline{W}\}
      \end{align*}
      Since $\{X, \overline{X}\} \neq \{W, \overline{W}\}$
      there must exist some pair of vertices $\{u, v\}$ such that $\{u, v\}$
      are in the same component of $\{W, \overline{W}\}$ and different
      components of $\{X, \overline{X}\}$.
      Let $H_{e}$ be the weight of the heaviest edge that was removed from $MST$.
      This implies that $dist(W, \overline{W}) = H_{e}$ and $d(u, v) \leq H_{e}$.
      Since $u$ and $v$ lie in different components of $\{X, \overline{X}\}$, then
      $dist(X, \overline{X}) \leq d(u, v)$.  Hence we have,
      \begin{align*}
        & dist(W, \overline{W}) = H_{e} \land d(u, v) \leq H_{e} & \\
        & \Rightarrow d(u, v) \leq dist(W, \overline{W}) & (I) \\
        & dist(X, \overline{X}) \leq d(u, v) & (II) \\
        & \Rightarrow dist(X, \overline{X}) \leq dist(W, \overline{W}) & \text{(I, II, Transitivity)}
      \end{align*}
      Which is a contradiction!\\ \\
      Therefore $dist(W, \overline{W})$ must be a maximum over all other paritions of $P$.
    \end{proof}

    Therefore the Algorithm MaximumMinimumDistance correctly produces the disjoint
    parition $\{W, \overline{W}\}$ of P such that,
    \begin{align*}
      dist(W, \overline{W}) = max(\{dist(S, \overline{S})\ |\ \{S, \overline{S}\} \text{ is a parition of P}\})
    \end{align*}
  \end{lemma}

  \begin{lemma}{3.2} Algorithm MaximumMinimumDistance runs in O($n^{2}$) time where $n = |P|$ \\ \\
    \textbf{Key Operations:} Computing the Euclidean distance between points, comparison of integers \\ \\
    There are $|P| \choose 2$ distinct pairs of points within $P$.  Thus to
    compute the PairwiseDistanceGraph, $|P| \choose 2$ Euclidean distances must be calculated. \\ \\
    The minmum spanning tree of the PairwiseDistanceGraph will have at most $|P| \choose 2$ edges,
    therefore determining the heaviest edge will require at most $|P| \choose 2$ - 1 comparisons.\\ \\
    Together we have,
    \begin{align*}
      & {|P| \choose 2} + {|P| \choose 2} - 1 & \\
      & = 2{|P| \choose 2} - 1 & \\
      & = |P|(|P| - 1) - 1 & \\
      & = |P|^{2} - |P| - 1 & \\
      & = O(|P|^{2}) &
    \end{align*}
    Therefore Algorithm MaximumMinimumDistance runs in O($n^{2}$) time where $n = |P|$.
  \end{lemma}

\end{question}

\end{document}
